# Data Flow

In most cases it is not enough to concatinate States in Rafcon in the right order, they also need to be associated with data. Also a plan, generated by a planner, does not contain objecst but rather kind of identifiers. e.g. "move robot kitchen". So there are two problems to overcome. At first, how to put these identifiers to the state. This is explained in section Parameter Passing. Secondly, how to map these identifiers to Objects. This is explained in section Runtime Data.  


## Parameter Passing

To pass a parameter from the plan to a state, the state needs to have an input Port of type "str", which has a correspoinding parameter in the Pddl action. The only difference is, that input Port does not have an questionmark at the beginning. e.g. the Pddl action parameter "?myParam" would match a states input port "myParam". But not any action parameter has to have a corresponding state parameter and vice versa.  

So for example if the State "move_state" has the following input ports:

|Port name|Data type|
|---|---|
|food|str|
|time|int|

and is annotated with the following pddl action: 

```PDDL
(:action cook 
 :Parameters (?chef - Person ?food - Food)
 [...])
```
The action paramter "?food" would match with the input port "food", and any value assigned to it will be passed to the State. So if "pizza" was assigned to "?food" in the plan, this would be the value of the corresponding data port "food". 


## Runtime Data

As seen above, Parameters can be passed to the states. But most of the time, that's only half the way, because these parameters are often only object identifiers. In order to give also access to the Objects, the "Runtime Data" field in the [Setup Form](/PlanningSetupForm.md) gives the possibility to name a file, in which this objects are defined. This file has to contain a (nested) json dictionary. For example, let's pretend a "pizza" object is needed, it has a "size", a "dough" and a list of "toppings". The file, in which the pizza was specified would look like thisː 

```json
{
"pizza":{"size":31,
         "dough":"yeast",
         "toppings":["cheese","ham","cheese","tomato","cheese"]
        }
}
```

When starting to execute the state machine, these specifications are copied into a global variable named **rtpp_data** in the global variable manager (gvm) of RAFCON. So when an identifier was passed to a state, the corresponding object can be read from this dictionary. For example, reading the size of the passed food e.g. the pizza would look like this: 

```python
 def execute(self, inputs, outputs, gvm):
   identifier = inputs['food'] #identifier → pizza
   rtpp_data = gvm.get_variable('rtpp_data') #rtpp_data → data provided in runtime data file
   food = rtpp_data[identifier] #now we have the pizza object
   size = food['size'] #now we have the size of the pizza bob is cooking
```


