# Planner Integration

The Task Planner Plugin comes not only with some built-in planners, but also provides the ability to integrate other ones with small effort. To do so, a planner integration Script has to be written, and used like described in the [Setup Form Section](/PlanningSetupForm.md). This page shows how to write an integration script for a planner.    

## Overview

The integration of a planner has to fulfill four tasks:  
At first it has to **trigger** the planner, to plan the specific task. After this process, the script has to **parse** the resulting plan into an internal plugin format. The third task is to **clean up** the system, in case the planner wrote any persistent files, and the last step of the script is to create a **report** and return it to the Plugin. 

## Integration
To integrate a Planner a class derived from the Plugins "PlannerInterface" needs to be created, and the method "plan_scenario" has to be implemented. The purpose of this method is to fulfill the four tasks mentioned above, and described below. This is a sceleton for an integration script: 

```Python
from rafcontpp.model.planner_interface import PlannerInterface
from rafcontpp.model.planning_report import PlanningReport
from rafcontpp.model.plan_step import PlanStep

class MyIntegration(PlannerInterface)Àê
     
     def plan_scenario(self, domain_path, facts_path, planner_argv, storage_path):
        #Do all four tasks here
        return PlanningReport(planning_successful, plan, generated_files, error_message)
```
### 1. Trigger the Planner
The first step of the integration is to trigger the Planner, e.g. make it plan the task. The arguments of the "plan_scenario" method, which are probably needed are "domain_path", which contains the path of the pddl domain file as string, "facts_path", which contains the path of the pddl facts path as string, and "planner_argv" which is an string array, which may contain additional planner arguments. Worth mentioning is, that the Plugin supports concurrent planning, e.g. more tasks can run at a time, so it may be useful to ensure, that two tasks with the same planner do not interfere with eachother e.g. by overriding tmp files.   

### 2. Parse the Plan
If planning was successful, the resulting plan has to parsed into the Plugin's internal format. A parsed Plan, is a list of "PlanSteps" in right order, and a PlanStep represents one action in the Plan, and is just the name of the instantiated action and a list of its arguments, e.g. the part "cook bob soup" or "(cook bob soup)(1)" in a plan would result in a PlanStep('cook',['bob','soup']). This is the constructor for "PlanStep":

```Python
PlanStep(action_name:String, [argument:String])
```
### 3. Clean Up
After parsing the plan, the system should be cleand up. To do so, all files generated by the Planner should be moved into the directory specified in "storage_path". Also a list should be generated, containing the the names of these files. If the planner did'nt generate a plan file, it maybe useful to rectify this here. 

### 4. Create a Planning Report
The last step is to report the planning results. Therefore a planning report has to be generated. It contains the following:  
1. Information about wether planning was successful.
2. The Plan, this is the parsed plan from Step two.
3. The list, containing the names of all generated files from Step three. 
4. An error message. If planning was successful, this message is irrelevant, but otherwise it would be nice, if it could indicate what went wrong.  

These informations are summed up in a "PlanningReport" Object, which has to be returned to the Plugin. This is it's constructor:

```Python
PlanningReport(planning_successful:Boolean, plan:[PlanStep], generated_files:[String], error_message:String)
```
